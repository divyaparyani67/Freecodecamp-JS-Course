
Q. 1. If you are unfamiliar with let, check out this challenge about the difference between let and var.

When you declare a variable with the var keyword, it is declared globally, or locally if declared inside a function.

The let keyword behaves similarly, but with some extra features. When you declare a variable with the let keyword inside a block, statement, or expression, its scope is limited to that block, statement, or expression.

Ans. function checkScope() {
  let i = 'function scope';
  if (true) {
     let i = 'block scope';
    console.log('Block scope i is: ', i);
  }
  console.log('Function scope i is: ', i);
  return i;
}


Q. 2 If you are unfamiliar with const, check out this challenge about the const keyword.

The const declaration has many use cases in modern JavaScript.

Some developers prefer to assign all their variables using const by default, unless they know they will need to reassign the value. Only in that case, they use let.

However, it is important to understand that objects (including arrays and functions) assigned to a variable using const are still mutable. Using the const declaration only prevents reassignment of the variable identifier.

Ans. const s = [5, 7, 2];
function editInPlace() {
  // Only change code below this line
  
  s[0] = 2;
  s[1]= 5;
  s[2]= 7;

  // Using s = [2, 5, 7] would be invalid

  // Only change code above this line
}
editInPlace();

**********************

Q. As seen in the previous challenge, const declaration alone doesn't really protect your data from mutation. To ensure your data doesn't change, JavaScript provides a function Object.freeze to prevent data mutation.

Ans. function freezeObj() {
  const MATH_CONSTANTS = {
    PI: 3.14
  };
  // Only change code below this line
 
 Object.freeze(MATH_CONSTANTS);

  // Only change code above this line
  try {
    MATH_CONSTANTS.PI = 99;
  } catch(ex) {
    console.log(ex);
  }
  return MATH_CONSTANTS.PI;
}
const PI = freezeObj();

************************


Q. In JavaScript, we often don't need to name our functions, especially when passing a function as an argument to another function. Instead, we create inline functions. We don't need to name these functions because we do not reuse them anywhere else.

To achieve this, we often use the following syntax:

Ans. const magic = ()  =>  {
  return new Date();
};

**********


Q.  Just like a regular function, you can pass arguments into an arrow function.

const doubler = (item) => item * 2;
doubler(4);
doubler(4) would return the value 8.

If an arrow function has a single parameter, the parentheses enclosing the parameter may be omitted.


Ans. const myConcat =  (arr1, arr2) =>  {
  return arr1.concat(arr2);
};

console.log(myConcat([1, 2], [3, 4, 5]));


*****************
Q. In order to help us create more flexible functions, ES6 introduces default parameters for functions.

Check out this code:
Ans. // Only change code below this line
const increment = (number, value = 1) => number + value;
// Only change code above this line

**********************
Q. In order to help us create more flexible functions, ES6 introduces the rest parameter for function parameters. With the rest parameter, you can create functions that take a variable number of arguments. These arguments are stored in an array that can be accessed later from inside the function. 

Ans. const sum = (...args) => {
  return args.reduce((a, b) => a + b, 0);
}


**************************
Q. ES6 introduces the spread operator, which allows us to expand arrays and other expressions in places where multiple parameters or elements are expected.

The ES5 code below uses apply() to compute the maximum value in an array:


Ans. const arr1 = ['JAN', 'FEB', 'MAR', 'APR', 'MAY'];
let arr2;

arr2 = [...arr1];  // Change this line

console.log(arr2); 


***************
Q. Destructuring assignment is special syntax introduced in ES6, for neatly assigning values taken directly from an object.

Consider the following ES5 code:

Ans. const HIGH_TEMPERATURES = {
  yesterday: 75,
  today: 77,
  tomorrow: 80
};

// Only change code below this line

const { today, tomorrow} = HIGH_TEMPERATURES;

// Only change code above this line


*******************

Q. Destructuring allows you to assign a new variable name when extracting values. You can do this by putting the new name after a colon when assigning the value.

Ans. const HIGH_TEMPERATURES = {
  yesterday: 75,
  today: 77,
  tomorrow: 80
};

// Only change code below this line
  
const {today: highToday,  tomorrow: highTomorrow} = HIGH_TEMPERATURES;

// Only change code above this line

**********

Q.You can use the same principles from the previous two lessons to destructure values from nested objects. 

Ans. const LOCAL_FORECAST = {
  yesterday: { low: 61, high: 75 },
  today: { low: 64, high: 77 },
  tomorrow: { low: 68, high: 80 }
};

// Only change code below this line
  
const { today: {low: lowToday,high:highToday } } =  LOCAL_FORECAST;
// Only change code above this line

*************************


Q. ES6 makes destructuring arrays as easy as destructuring objects.

One key difference between the spread operator and array destructuring is that the spread operator unpacks all contents of an array into a comma-separated list. Consequently, you cannot pick or choose which elements you want to assign to variables.

Ans. let a = 8, b = 6;
// Only change code below this line

 [ a, b] = [b, a];

*************************************

Q.In some situations involving array destructuring, we might want to collect the rest of the elements into a separate array. 

Ans. 
const source = [1,2,3,4,5,6,7,8,9,10];
function removeFirstTwo(list) {
  // Only change code below this line
  const arr = list.slice() ; // Change this line
  // Only change code above this line
  return arr;
}
const arr = removeFirstTwo(source);


***********
Q. In some situations involving array destructuring, we might want to collect the rest of the elements into a separate array.

Ans. const source = [1,2,3,4,5,6,7,8,9,10];
function removeFirstTwo(list) {
  // Only change code below this line
  const [a,b,  ...arr] = list; // Change this line
  // Only change code above this line
  return arr;
}
const arr = removeFirstTwo(source);


*****************************

Q.In some cases, you can destructure the object in a function argument itself
Ans. const stats = {
  max: 56.78,
  standard_deviation: 4.34,
  median: 34.54,
  mode: 23.87,
  min: -0.75,
  average: 35.85
};

// Only change code below this line
 
const half = ({max, min}) => (max + min) / 2.0;
// Only change code above this line


***************

Q. A new feature of ES6 is the template literal. This is a special type of string that makes creating complex strings easier.

Template literals allow you to create multi-line strings and to use string interpolation features to create strings.

Ans. const result = {
  success: ["max-length", "no-amd", "prefer-arrow-functions"],
  failure: ["no-var", "var-on-top", "linebreak"],
  skipped: ["no-extra-semi", "no-dup-keys"]
};
function makeList(arr) {
  // Only change code below this line
  const failureItems =  [];
   for(let i = 0; i < arr.length; i++) {

     failureItems.push (`<li class="text-warning">${arr[i]}</li>`);
   } {
      return failureItems;

   }
  // Only change code above this line 
 
}

const failuresList = makeList(result.failure);
