
Q. 1. If you are unfamiliar with let, check out this challenge about the difference between let and var.

When you declare a variable with the var keyword, it is declared globally, or locally if declared inside a function.

The let keyword behaves similarly, but with some extra features. When you declare a variable with the let keyword inside a block, statement, or expression, its scope is limited to that block, statement, or expression.

Ans. function checkScope() {
  let i = 'function scope';
  if (true) {
     let i = 'block scope';
    console.log('Block scope i is: ', i);
  }
  console.log('Function scope i is: ', i);
  return i;
}


Q. 2 If you are unfamiliar with const, check out this challenge about the const keyword.

The const declaration has many use cases in modern JavaScript.

Some developers prefer to assign all their variables using const by default, unless they know they will need to reassign the value. Only in that case, they use let.

However, it is important to understand that objects (including arrays and functions) assigned to a variable using const are still mutable. Using the const declaration only prevents reassignment of the variable identifier.

Ans. const s = [5, 7, 2];
function editInPlace() {
  // Only change code below this line
  
  s[0] = 2;
  s[1]= 5;
  s[2]= 7;

  // Using s = [2, 5, 7] would be invalid

  // Only change code above this line
}
editInPlace();

**********************

Q. As seen in the previous challenge, const declaration alone doesn't really protect your data from mutation. To ensure your data doesn't change, JavaScript provides a function Object.freeze to prevent data mutation.

Ans. function freezeObj() {
  const MATH_CONSTANTS = {
    PI: 3.14
  };
  // Only change code below this line
 
 Object.freeze(MATH_CONSTANTS);

  // Only change code above this line
  try {
    MATH_CONSTANTS.PI = 99;
  } catch(ex) {
    console.log(ex);
  }
  return MATH_CONSTANTS.PI;
}
const PI = freezeObj();

************************


Q. In JavaScript, we often don't need to name our functions, especially when passing a function as an argument to another function. Instead, we create inline functions. We don't need to name these functions because we do not reuse them anywhere else.

To achieve this, we often use the following syntax:

Ans. const magic = ()  =>  {
  return new Date();
};

**********


Q.  Just like a regular function, you can pass arguments into an arrow function.

const doubler = (item) => item * 2;
doubler(4);
doubler(4) would return the value 8.

If an arrow function has a single parameter, the parentheses enclosing the parameter may be omitted.


Ans. const myConcat =  (arr1, arr2) =>  {
  return arr1.concat(arr2);
};

console.log(myConcat([1, 2], [3, 4, 5]));


*****************
Q. In order to help us create more flexible functions, ES6 introduces default parameters for functions.

Check out this code:
Ans. // Only change code below this line
const increment = (number, value = 1) => number + value;
// Only change code above this line

**********************
Q. In order to help us create more flexible functions, ES6 introduces the rest parameter for function parameters. With the rest parameter, you can create functions that take a variable number of arguments. These arguments are stored in an array that can be accessed later from inside the function. 

Ans. const sum = (...args) => {
  return args.reduce((a, b) => a + b, 0);
}
